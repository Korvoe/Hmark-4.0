// Code generated by TestPretty. DO NOT EDIT.
// GENERATED FILE DO NOT EDIT
1:
-
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT
		i.indisunique
		AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i ON
			ct.oid
			= i.indrelid
	JOIN pg_catalog.pg_class
			AS ci ON
			ci.oid
			= i.indexrelid
	JOIN pg_catalog.pg_am
			AS am ON
			ci.relam
			= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

7:
-------
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT
		i.indisunique AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	)
		AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		)
			AS i ON
			ct.oid
			= i.indrelid
	JOIN pg_catalog.pg_class
			AS ci ON
			ci.oid
			= i.indexrelid
	JOIN pg_catalog.pg_am
			AS am ON
			ci.relam
			= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

10:
----------
SELECT
	NULL
		AS table_cat,
	n.nspname
		AS table_schem,
	ct.relname
		AS table_name,
	NOT
		i.indisunique AS non_unique,
	NULL
		AS index_qualifier,
	ci.relname
		AS index_name,
	CASE i.indisclustered
	WHEN true
	THEN 1
	ELSE CASE am.amname
	WHEN 'hash'
	THEN 2
	ELSE 3
	END
	END
		AS type,
	(i.keys).n
		AS ordinal_position,
	btrim(
		pg_catalog.pg_get_indexdef(
			ci.oid,
			(i.keys).n,
			false
		),
		'"'
	) AS column_name,
	CASE am.amcanorder
	WHEN true
	THEN CASE i.indoption[(i.keys).n - 1]
	& 1
	WHEN 1
	THEN 'D'
	ELSE 'A'
	END
	ELSE NULL
	END
		AS asc_or_desc,
	ci.reltuples
		AS cardinality,
	ci.relpages
		AS pages,
	pg_catalog.pg_get_expr(
		i.indpred,
		i.indrelid
	)
		AS filter_condition
FROM
	pg_catalog.pg_class
		AS ct
	JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
	JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
		) AS i ON
			ct.oid
			= i.indrelid
	JOIN pg_catalog.pg_class
			AS ci ON
			ci.oid
			= i.indexrelid
	JOIN pg_catalog.pg_am
			AS am ON
			ci.relam
			= am.oid
WHERE
	true
	AND n.nspname
		= 'public'
	AND ct.relname
		= 'j'
ORDER BY
	non_unique,
	type,
	index_name,
	ordinal_position

13:
-------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true
         THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         )
			AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1
         THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
         ) AS i ON
			ct.oid
			= i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON
			ci.oid
			= i.indexrelid
    JOIN pg_catalog.pg_am
			AS am ON
			ci.relam
			= am.oid
   WHERE true
     AND n.nspname
         = 'public'
     AND ct.relname
         = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

15:
---------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true
         THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1
         THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
         ) AS i ON
			ct.oid
			= i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON
			ci.oid
			= i.indexrelid
    JOIN pg_catalog.pg_am
			AS am ON
			ci.relam
			= am.oid
   WHERE true
     AND n.nspname
         = 'public'
     AND ct.relname
         = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

24:
------------------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true
         THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
         ) AS i ON
			ct.oid
			= i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON
			ci.oid
			= i.indexrelid
    JOIN pg_catalog.pg_am
			AS am ON
			ci.relam
			= am.oid
   WHERE true
     AND n.nspname
         = 'public'
     AND ct.relname
         = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

25:
-------------------------
  SELECT NULL
			AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash'
         THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END
			AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid
                   = i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON
			ci.oid
			= i.indexrelid
    JOIN pg_catalog.pg_am
			AS am ON
			ci.relam
			= am.oid
   WHERE true
     AND n.nspname
         = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

27:
---------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid
                   = i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON ci.oid
         = i.indexrelid
    JOIN pg_catalog.pg_am
			AS am ON
			ci.relam
			= am.oid
   WHERE true
     AND n.nspname
         = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

29:
-----------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END
			AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages
			AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid
                   = i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON ci.oid
         = i.indexrelid
    JOIN pg_catalog.pg_am
			AS am ON ci.relam
         = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

30:
------------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         )
			AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT
				i.indexrelid,
				i.indrelid,
				i.indoption,
				i.indisunique,
				i.indisclustered,
				i.indpred,
				i.indexprs,
				information_schema._pg_expandarray(
					i.indkey
				)
					AS keys
			FROM
				pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid
                   = i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON ci.oid
         = i.indexrelid
    JOIN pg_catalog.pg_am
			AS am ON ci.relam
         = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

32:
--------------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL
			AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid
                   = i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON ci.oid
         = i.indexrelid
    JOIN pg_catalog.pg_am
			AS am ON ci.relam
         = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

33:
---------------------------------
  SELECT NULL AS table_cat,
         n.nspname
			AS table_schem,
         ct.relname
			AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname
			AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class
			AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid
                   = i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON ci.oid
         = i.indexrelid
    JOIN pg_catalog.pg_am
			AS am ON ci.relam
         = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

34:
----------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON
			ct.relnamespace
			= n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid
                   = i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON ci.oid
         = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON
			ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

35:
-----------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples
			AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON ct.relnamespace
        = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid
                   = i.indrelid
    JOIN pg_catalog.pg_class
			AS ci ON ci.oid
         = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON
			ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

37:
-------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON ct.relnamespace
        = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid
                   = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON
			ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON
			ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

38:
--------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n
			AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace
			AS n ON ct.relnamespace
        = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON
			ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON
			ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

40:
----------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT
			i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON
			ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON
			ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON
			ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

41:
-----------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON
			ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index
					AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON
			ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON
			ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

43:
-------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON
			ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON
			ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam
                                   = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

44:
--------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1]
         & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON
			ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid
                                      = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam
                                   = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

50:
--------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON
			ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid
                                      = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam
                                   = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

52:
----------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON
			ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       )
					AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid
                                      = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

54:
------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON
			ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid
                                      = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique,
         type,
         index_name,
         ordinal_position

55:
-------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON
			ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid
                                      = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

56:
--------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname
         WHEN 'hash' THEN 2
         ELSE 3
         END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace
                                         = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid
                                      = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

58:
----------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace
                                         = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid
                                      = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true
     AND n.nspname = 'public'
     AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

59:
-----------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace
                                         = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

64:
----------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(
				ci.oid,
				(i.keys).n,
				false
			),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

66:
------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(
					i.indkey
			       ) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

71:
-----------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(
			i.indpred,
			i.indrelid
         ) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

74:
--------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1
         WHEN 1 THEN 'D'
         ELSE 'A'
         END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

79:
-------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true
         THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

89:
-----------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(
			pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false),
			'"'
         ) AS column_name,
         CASE am.amcanorder
         WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

90:
------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered
         WHEN true THEN 1
         ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END
         END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder
         WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

110:
--------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder
         WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END
         ELSE NULL
         END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

138:
------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid,
			       i.indrelid,
			       i.indoption,
			       i.indisunique,
			       i.indisclustered,
			       i.indpred,
			       i.indexprs,
			       information_schema._pg_expandarray(i.indkey) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

166:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys
			  FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

196:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (
			SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i
         ) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

203:
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON
			ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

210:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid
                                                                                                                                                                                                            = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

223:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct
    JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid
    JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid
    JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid
    JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

420:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat,
         n.nspname AS table_schem,
         ct.relname AS table_name,
         NOT i.indisunique AS non_unique,
         NULL AS index_qualifier,
         ci.relname AS index_name,
         CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type,
         (i.keys).n AS ordinal_position,
         btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name,
         CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc,
         ci.reltuples AS cardinality,
         ci.relpages AS pages,
         pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

626:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition
    FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid
   WHERE true AND n.nspname = 'public' AND ct.relname = 'j'
ORDER BY non_unique, type, index_name, ordinal_position

1154:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SELECT NULL AS table_cat, n.nspname AS table_schem, ct.relname AS table_name, NOT i.indisunique AS non_unique, NULL AS index_qualifier, ci.relname AS index_name, CASE i.indisclustered WHEN true THEN 1 ELSE CASE am.amname WHEN 'hash' THEN 2 ELSE 3 END END AS type, (i.keys).n AS ordinal_position, btrim(pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false), '"') AS column_name, CASE am.amcanorder WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 WHEN 1 THEN 'D' ELSE 'A' END ELSE NULL END AS asc_or_desc, ci.reltuples AS cardinality, ci.relpages AS pages, pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS filter_condition FROM pg_catalog.pg_class AS ct JOIN pg_catalog.pg_namespace AS n ON ct.relnamespace = n.oid JOIN (SELECT i.indexrelid, i.indrelid, i.indoption, i.indisunique, i.indisclustered, i.indpred, i.indexprs, information_schema._pg_expandarray(i.indkey) AS keys FROM pg_catalog.pg_index AS i) AS i ON ct.oid = i.indrelid JOIN pg_catalog.pg_class AS ci ON ci.oid = i.indexrelid JOIN pg_catalog.pg_am AS am ON ci.relam = am.oid WHERE true AND n.nspname = 'public' AND ct.relname = 'j' ORDER BY non_unique, type, index_name, ordinal_position


